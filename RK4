import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp

# Physics constants and initial conditions encapsulated in a class
class PendulumParameters:
    def __init__(self, L1, L2, m1, m2, g=9.81, gamma1=0.1, gamma2=0.1):
        self.L1 = L1    # Length of pendulum 1 (m)
        self.L2 = L2    # Length of pendulum 2 (m)
        self.m1 = m1    # Mass of pendulum 1 (kg)
        self.m2 = m2    # Mass of pendulum 2 (kg)
        self.g = g      # Gravity (m/s^2)
        self.gamma1 = gamma1  # Damping coefficient for pendulum 1
        self.gamma2 = gamma2  # Damping coefficient for pendulum 2

class InitialConditions:
    def __init__(self, theta1_0, theta2_0, omega1_0, omega2_0):
        self.theta1_0 = theta1_0  # Initial angle for pendulum 1 (radians)
        self.theta2_0 = theta2_0  # Initial angle for pendulum 2 (radians)
        self.omega1_0 = omega1_0  # Initial angular velocity for pendulum 1
        self.omega2_0 = omega2_0  # Initial angular velocity for pendulum 2

# Encapsulate the simulation logic in a class
class DoublePendulumSimulator:
    def __init__(self, params, initial_conditions, T_total, dt):
        self.params = params
        self.initial_conditions = initial_conditions
        self.T_total = T_total    # Total simulation time (s)
        self.dt = dt              # Time step (s)
        self.time = np.arange(0, T_total, dt)

    def run_simulation(self):
        # Runge-Kutta 4th order method (via solve_ivp)
        initial_state = [self.initial_conditions.theta1_0, self.initial_conditions.omega1_0,
                         self.initial_conditions.theta2_0, self.initial_conditions.omega2_0]
        solution = solve_ivp(self._equations_of_motion, [0, self.T_total], initial_state,
                             t_eval=self.time, method='RK45')
        self.theta1 = solution.y[0]
        self.theta2 = solution.y[2]
    
    def _equations_of_motion(self, t, state):
        theta1, omega1, theta2, omega2 = state
        delta_theta = theta1 - theta2

        L1, L2, m1, m2 = self.params.L1, self.params.L2, self.params.m1, self.params.m2
        g, gamma1, gamma2 = self.params.g, self.params.gamma1, self.params.gamma2
        
        denom1 = (2 * m1 + m2 - m2 * np.cos(2 * delta_theta))
        denom2 = (L2 / L1) * denom1

        # Damped angular accelerations
        d_omega1 = (-g * (2 * m1 + m2) * np.sin(theta1) - m2 * g * np.sin(theta1 - 2 * theta2) 
                    - 2 * np.sin(delta_theta) * m2 * (omega2 ** 2 * L2 + omega1 ** 2 * L1 * np.cos(delta_theta)) 
                    - gamma1 * omega1) / (L1 * denom1)

        d_omega2 = (2 * np.sin(delta_theta) * (omega1 ** 2 * L1 * (m1 + m2) + g * (m1 + m2) * np.cos(theta1) 
                    + omega2 ** 2 * L2 * m2 * np.cos(delta_theta)) - gamma2 * omega2) / (L2 * denom2)
        
        return [omega1, d_omega1, omega2, d_omega2]

    def get_cartesian_coordinates(self):
        # Convert angles to Cartesian coordinates
        x1 = self.params.L1 * np.sin(self.theta1)
        y1 = -self.params.L1 * np.cos(self.theta1)
        x2 = x1 + self.params.L2 * np.sin(self.theta2)
        y2 = y1 - self.params.L2 * np.cos(self.theta2)
        return x1, y1, x2, y2

# Visualization class
class PendulumVisualizer:
    def __init__(self, simulator):
        self.simulator = simulator

    def animate_pendulum(self):
        x1, y1, x2, y2 = self.simulator.get_cartesian_coordinates()
        time = self.simulator.time
        plt.figure(figsize=(6, 6))
        for i in range(0, len(time), 10):
            plt.clf()
            plt.plot([0, x1[i], x2[i]], [0, y1[i], y2[i]], marker='o', color='b')
            plt.xlim([-2, 2])
            plt.ylim([-2, 2])
            plt.title(f"Double Pendulum with Damping at t = {time[i]:.2f}s")
            plt.pause(0.01)
        plt.show()

    def plot_displacement(self):
        time = self.simulator.time
        theta1 = self.simulator.theta1
        theta2 = self.simulator.theta2

        plt.figure(figsize=(10, 5))
        plt.plot(time, theta1, label='Theta1 (Pendulum 1)')
        plt.plot(time, theta2, label='Theta2 (Pendulum 2)')
        plt.title('Double Pendulum with Damping: Angular Displacement vs Time')
        plt.xlabel('Time (s)')
        plt.ylabel('Angle (radians)')
        plt.grid(True)
        plt.legend()
        plt.show()

# Setup parameters and run simulation
params = PendulumParameters(L1=1.0, L2=1.0, m1=1.0, m2=1.0, gamma1=0.1, gamma2=0.1)
initial_conditions = InitialConditions(theta1_0=np.pi / 2, theta2_0=np.pi / 2, omega1_0=0.0, omega2_0=0.0)
simulator = DoublePendulumSimulator(params, initial_conditions, T_total=20, dt=0.01)

# Run the simulation
simulator.run_simulation()

# Visualize the simulation
visualizer = PendulumVisualizer(simulator)
visualizer.animate_pendulum()
visualizer.plot_displacement()